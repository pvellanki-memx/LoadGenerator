import configparser
import socket
import struct
import time
from multiprocessing import Process
from sbe_encoder_decoder import UTCTimestampNanos, NewOrderSingle,  ShortTwoSidedQuote,ShortTwoSideBulkQuote, LongTwoSideBulkQuote, ShortOneSideBulkQuote, LongOneSideBulkQuote,MatchTradePreventionType,MtpGroupIDType, LongOneSideQuote,LongTwoSidedQuote
from sbe_encoder_decoder import UINT32,UINT16, OrdType, PriceType,TimeInForceType, ExecInstType, TradingCapacityType, SideType, PartyID, PartiesGroup,PartyIDSource, PartyRoleType, ShortPriceType, OptionsSecurityID,ShortOneSideQuote
from random import choices, randint
import string
from random import choices, randint



# Read configuration from config.ini
config = configparser.ConfigParser()
config.read('config.ini')


# Read connection details from connections.cfg
connection_config = configparser.ConfigParser()
connection_config.read(config['Server']['config_file'])

# Define the MESSAGE_TYPES dictionary
MESSAGE_TYPES = {
    "NewOrderSingle": 1,
    "ShortTwoSidedBulkQuote": 2,
    "LongTwoSidedBulkQuote": 3,
    "ShortOneSidedBulkQuote": 4,
    "LongOneSidedBulkQuote": 5,
    "ExecutionReport_New": 11,
    "ExecutionReport_BulkQuote_PendingNew": 12,
    "ExecutionReport_BulkQuote_ComponentNew": 13,
    "ExecutionReport_Rejected": 14,
    "ExecutionReport_Trade": 15,
    "ExecutionReport_PendingCancel": 16,
    "ExecutionReport_Canceled": 17,
    "ExecutionReport_PendingReplace": 18,
    "ExecutionReport_Replaced": 19,
    "ExecutionReport_TradeCorrection": 20,
    "ExecutionReport_TradeBreak": 21,
    "ExecutionReport_Restatement": 22,
    "PendingMassCancel": 23,
    "MassCancelReject": 24,
    "MassCancelDone": 25,
    "OrderCancelReject": 26,
    "AllocationInstructionAck": 27,
    "AllocationReport": 28,
    "UserNotification": 29,
    "MassCancelClearLockoutReject": 30,
    "MassCancelClearLockoutDone": 31
}

'''
# TCP/IP connection details
host = connection_config['Session1']['host']
port = int(connection_config['Session1']['port'])
user = connection_config['Session1']['user']
password = connection_config['Session1']['password']
token = f'{user}:{password}'
'''

# Read other configuration parameters
message_rate = config.getint('Load', 'message_rate')
duration = config.getint('Load', 'duration')

weights = {
    'NewOrderSingle': config.getfloat('Weights', 'NewOrderSingle'),
    'ShortTwoSideBulkQuote': config.getfloat('Weights', 'ShortTwoSideBulkQuote'),
    'LongTwoSideBulkQuote': config.getfloat('Weights', 'LongTwoSideBulkQuote'),
    'ShortOneSideBulkQuote': config.getfloat('Weights', 'ShortOneSideBulkQuote'),
    'LongOneSideBulkQuote': config.getfloat('Weights', 'LongOneSideBulkQuote')
}

security_ids = config.get('OptionsSecurityIDs', 'security_ids').split(',')

template_file = config.get('Template', 'template_file')

# Load template.txt
with open(template_file) as template_file:
    template = template_file.read()

# Establish SBE TCP session
def establish_session(session_name):


    # Get connection details for the specified session name
    host = connection_config[session_name]['host']
    port = int(connection_config[session_name]['port'])
    user = connection_config[session_name]['user']
    password = connection_config[session_name]['password']
    token = f'{user}:{password}'
    


        # Login request
    message_type = 100
    token_type = 'P'  # Assuming token type is always 'P'
    token_length = len(token)
    header = struct.pack('!BHB', message_type, token_length + 1, token_type.encode('utf-8')[0])
    message = header + token.encode('utf-8')

    # Create a socket and establish the connection
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((host, port))

    # Set socket to binary mode
    client_socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

        # Send the login request
    client_socket.sendall(message)

    # Receive and handle the response
    response_header = client_socket.recv(3)
    response_type, response_length = struct.unpack('!B H', response_header)
    print(response_type, response_length)

    if response_type == 1:  # Login Accepted
        response_message = client_socket.recv(response_length)
        print("Login Accepted:", response_message.decode('utf-8'))
        session_id = None
    elif response_type == 2:  # Login Rejected
        response_message = client_socket.recv(response_length)
        print("Login Rejected:", response_message.decode('utf-8'))
        client_socket.close()
        exit()  # Exit the script gracefully after login rejection
    else:
        print("Invalid response received.")
        client_socket.close()
        exit()  # Exit the script if an invalid response is received

    # Continue with the session
    while True:
        response_header = client_socket.recv(11)
        response_type, response_length, session_id = struct.unpack('!B H Q', response_header)
        print(response_header, response_type, response_length)

        if response_type == 3:  # Start of Session
            print("Start of Session. Session ID:", session_id)
            break
        else:
            print("Invalid response received.")


    # Stream Request
    stream_request_type = 103
    stream_request_length = 16  # 4 bytes for message type and length, 8 bytes for session ID, 8 bytes for next sequence number
    NEXT_SEQUENCE_NUMBER = 0
    stream_request_header = struct.pack('!BHQQ', stream_request_type, stream_request_length, session_id, NEXT_SEQUENCE_NUMBER)
    stream_request = stream_request_header

    # Send the Stream Request
    client_socket.sendall(stream_request)

    response_header = client_socket.recv(3)
    response_type, response_length = struct.unpack('!B H', response_header)
    print(response_type, response_length)

    if response_type == 9:  # Stream Rejected
        response_message = client_socket.recv(response_length)
        reject_code = response_message.decode('utf-8')
        print("Stream Rejected. Reject Code:", reject_code)
        client_socket.close()
        exit()
    elif response_type == 10:  # End of Stream
        response_message = client_socket.recv(response_length)
        print("End of Stream")
        client_socket.close()
        exit()
    elif response_type == 8:  # Stream Begin
        response_message = client_socket.recv(response_length - 2)
        print(response_message)
        NEXT_SEQUENCE_NUMBER  = struct.unpack('!Q', response_message[3:11])
        print("Stream Begin received")
    else:
        print("Invalid Message received")
    

    return client_socket, session_id

# Generate a random message type based on the weights
def generate_message_type():
    message_types = list(weights.keys())
    return choices(message_types, weights=list(weights.values()), k=1)[0]

def generate_message(message_type,session_name):
    if message_type == 'NewOrderSingle':
  
        # Generate values for the fields
        sending_time = UTCTimestampNanos(int(time.time() * 10**9))
        cl_ord_id = ''.join(choices(string.ascii_letters + string.digits, k=20))
        options_security_id = OptionsSecurityID(choices(security_ids)[0])
        side = SideType(value=SideType.BUY)  # Set the side to "Buy"
        order_qty = UINT32(value=randint(1, 10))
        ord_type = OrdType(value=OrdType.LIMIT)
        price = PriceType(50000000000000000)  # Set the price with 10^8 multiplier
        time_in_force = TimeInForceType(value=TimeInForceType.DAY)  # Set the time in force to "Day"
        exec_inst = ExecInstType(value=ExecInstType.ParticipateDoNotInitiate)  # Set the execution instructions
        trading_capacity = TradingCapacityType(value=TradingCapacityType.CUSTOMER)  # Set the trading capacity
        efid = connection_config[session_name]['EFID']
        party_id = PartyID(efid)
        party_id_source = PartyIDSource('D')
        party_role = PartyRoleType(1)
        party_id1 = PartyID(efid)
        party_id_source1 = PartyIDSource('D')
        party_role1 = PartyRoleType(66)
        parties = [PartiesGroup(party_ids=[[party_id, party_id_source, party_role],[party_id1, party_id_source1, party_role1]])]

        # Create an instance of NewOrderSingle and set the field values
        new_order_single = NewOrderSingle(
            sending_time=sending_time,
            cl_ord_id=cl_ord_id,
            options_security_id=options_security_id,
            side=side,
            order_qty=order_qty,
            ord_type=ord_type,
            price=price,
            time_in_force=time_in_force,
            exec_inst=exec_inst,
            trading_capacity=trading_capacity,
            parties_group=parties
        )

        unsequenced_message = struct.pack('!BH', 104, 109)  # MessageType=104, MessageLength=91, TCP Header Length=102
        # Encode the NewOrderSingle instance
        encoded_message = new_order_single.encode()
        message = unsequenced_message + encoded_message

        # Print the encoded message
        print('NewOrderSingle:')
        print(encoded_message)

        return message

    elif message_type == 'NewOrderSingle_mkt':
  
        # Generate values for the fields
        sending_time = UTCTimestampNanos(int(time.time() * 10**9))
        cl_ord_id = ''.join(choices(string.ascii_letters + string.digits, k=20))
        options_security_id = OptionsSecurityID(choices(security_ids)[0])
        side = SideType(value=SideType.BUY)  # Set the side to "Buy"
        order_qty = UINT32(value=randint(1, 10))
        ord_type = OrdType(value=OrdType.MARKET)
        price = PriceType(None)  # Set the price with 10^8 multiplier
        time_in_force = TimeInForceType(value=TimeInForceType.DAY)  # Set the time in force to "Day"
        exec_inst = ExecInstType(value=ExecInstType.ParticipateDoNotInitiate)  # Set the execution instructions
        trading_capacity = TradingCapacityType(value=TradingCapacityType.MARKET_MAKER)  # Set the trading capacity
        efid = connection_config[session_name]['EFID']
        party_id = PartyID(efid)
        party_id_source = PartyIDSource('D')
        party_role = PartyRoleType(1)
        parties = [PartiesGroup(party_ids=[[party_id, party_id_source, party_role]])]

        # Create an instance of NewOrderSingle and set the field values
        new_order_single = NewOrderSingle(
            sending_time=sending_time,
            cl_ord_id=cl_ord_id,
            options_security_id=options_security_id,
            side=side,
            order_qty=order_qty,
            ord_type=ord_type,
            price=price,
            time_in_force=time_in_force,
            exec_inst=exec_inst,
            trading_capacity=trading_capacity,
            parties_group=parties
        )

        unsequenced_message = struct.pack('!BH', 104, 91)  # MessageType=104, MessageLength=6, TCP Header Length=102
        # Encode the NewOrderSingle instance
        encoded_message = new_order_single.encode()
        message = unsequenced_message + encoded_message

        # Print the encoded message
        print('NewOrderSingle:')
        print(encoded_message)

        return message


    elif message_type == 'ShortTwoSideBulkQuote':
        # Generate ShortTwoSideBulkQuote message
        sending_time = UTCTimestampNanos(int(time.time() * 10**9))
        cl_ord_id = ''.join(choices(string.ascii_uppercase + string.digits, k=20))
        time_in_force = TimeInForceType(value=TimeInForceType.DAY)
        exec_inst = ExecInstType(value=ExecInstType.ParticipateDoNotInitiate)
        trading_capacity = TradingCapacityType(value=TradingCapacityType.MARKET_MAKER)
        mtp_group_id = MtpGroupIDType(1)
        match_trade_prevention = MatchTradePreventionType(1)
        cancel_group_id = UINT16(1)
        risk_group_id = UINT16(1)
        efid = connection_config[session_name]['EFID']
        party_id = PartyID(efid)
        party_id_source = PartyIDSource('D')
        party_role = PartyRoleType(1)
        party_id1 = PartyID(efid)
        party_id_source1 = PartyIDSource('D')
        party_role1 = PartyRoleType(66)
        parties = [PartiesGroup(party_ids=[[party_id, party_id_source, party_role],[party_id1, party_id_source1, party_role1]])]
        quote1 = ShortTwoSidedQuote(list_seq_no=1, options_security_id='U2cn66kp', bid_size=10, bid_mantissa=50000,offer_size=20,offer_mantissa=75000)
        quote2 = ShortTwoSidedQuote(list_seq_no=2, options_security_id='U2cn66kp', bid_size=15,bid_mantissa=80000, offer_size=25, offer_mantissa=85000)

        quotes = [quote1, quote2]
        

        short_two_side_bulk_quote = ShortTwoSideBulkQuote(
            sending_time=sending_time,
            cl_ord_id=cl_ord_id,
            time_in_force=time_in_force,
            exec_inst=exec_inst,
            trading_capacity=trading_capacity,
            mtp_group_id=mtp_group_id,
            match_trade_prevention=match_trade_prevention,
            cancel_group_id=cancel_group_id,
            risk_group_id=risk_group_id,
            parties=parties,
            quotes=quotes
        )

        # Encode the ShortTwoSideBulkQuote instance
        encoded_message = short_two_side_bulk_quote.encode()
        unsequenced_message = struct.pack('!BH', 104, 144)  # MessageType=104, MessageLength=6, TCP Header Length=102
        message = unsequenced_message + encoded_message

        # Print the encoded message
        print('short_two_side_bulk_quote:')
        print(message)
        return message


    elif message_type == 'LongTwoSideBulkQuote':
        # Generate LongTwoSideBulkQuote message
        sending_time = UTCTimestampNanos(int(time.time() * 10**9))
        cl_ord_id = ''.join(choices(string.ascii_uppercase + string.digits, k=20))
        time_in_force = TimeInForceType(value=TimeInForceType.DAY)
        exec_inst = ExecInstType(value=ExecInstType.ParticipateDoNotInitiate)
        trading_capacity = TradingCapacityType(value=TradingCapacityType.MARKET_MAKER)
        mtp_group_id = MtpGroupIDType(0)
        match_trade_prevention = MatchTradePreventionType(0)
        cancel_group_id = UINT16(0)
        risk_group_id = UINT16(0)
        efid = connection_config[session_name]['EFID']
        party_id = PartyID(efid)
        party_id_source = PartyIDSource('D')
        party_role = PartyRoleType(1)
        party_id1 = PartyID(efid)
        party_id_source1 = PartyIDSource('D')
        party_role1 = PartyRoleType(66)
        parties = [PartiesGroup(party_ids=[[party_id, party_id_source, party_role],[party_id1, party_id_source1, party_role1]])]
        quote1 = LongTwoSidedQuote(list_seq_no=1, options_security_id='U2cn66kp', bid_size=10, bid_px=1000000000000000,offer_size=20,offer_px=15000000000000000)
        quote2 = LongTwoSidedQuote(list_seq_no=2, options_security_id='U2cn66kp',bid_size=15,bid_px=20000000000000000, offer_size=25, offer_px=250000000000000000)

        quotes = [quote1, quote2]
        

        long_two_side_bulk_quote = LongTwoSideBulkQuote(
            sending_time=sending_time,
            cl_ord_id=cl_ord_id,
            time_in_force=time_in_force,
            exec_inst=exec_inst,
            trading_capacity=trading_capacity,
            mtp_group_id=mtp_group_id,
            match_trade_prevention=match_trade_prevention,
            cancel_group_id=cancel_group_id,
            risk_group_id=risk_group_id,
            parties=parties,
            quotes=quotes
        )

        # Encode the LongTwoSideBulkQuote instance
        encoded_message = long_two_side_bulk_quote.encode()
        unsequenced_message = struct.pack('!BH', 104, 152)  # MessageType=104, MessageLength=6, TCP Header Length=102
        message = unsequenced_message + encoded_message

        # Print the encoded messag´
        print('long_two_side_bulk_quote:')
        print(message)
        return message
     

    elif message_type == 'ShortOneSideBulkQuote':
        sending_time = UTCTimestampNanos(int(time.time() * 10**9))
        cl_ord_id = ''.join(choices(string.ascii_uppercase + string.digits, k=20))
        time_in_force = TimeInForceType(value=TimeInForceType.DAY)
        exec_inst = ExecInstType(value=ExecInstType.ParticipateDoNotInitiate)
        trading_capacity = TradingCapacityType(value=TradingCapacityType.MARKET_MAKER)
        mtp_group_id = MtpGroupIDType(0)
        match_trade_prevention = MatchTradePreventionType(0)
        cancel_group_id = UINT16(0)
        risk_group_id = UINT16(0)
        efid = connection_config[session_name]['EFID']
        party_id = PartyID(efid)
        party_id_source = PartyIDSource('D')
        party_role = PartyRoleType(1)
        party_id1 = PartyID(efid)
        party_id_source1 = PartyIDSource('D')
        party_role1 = PartyRoleType(66)
        parties = [PartiesGroup(party_ids=[[party_id, party_id_source, party_role],[party_id1, party_id_source1, party_role1]])]
        quote1 = ShortOneSideQuote(list_seq_no=1, options_security_id='U2cn66kp', side = SideType(value=SideType.BUY),quantity=11, price=10000)
        quote2 = ShortOneSideQuote(list_seq_no=2, options_security_id='U2cn66kp',side=SideType(value=SideType.SELL), quantity=12, price=20000)

        quotes = [quote1, quote2]
        

        short_one_side_bulk_quote = ShortOneSideBulkQuote(
            sending_time=sending_time,
            cl_ord_id=cl_ord_id,
            time_in_force=time_in_force,
            exec_inst=exec_inst,
            trading_capacity=trading_capacity,
            mtp_group_id=mtp_group_id,
            match_trade_prevention=match_trade_prevention,
            cancel_group_id=cancel_group_id,
            risk_group_id=risk_group_id,
            parties=parties,
            quotes=quotes
        )

        # Encode the ShortTwoSideBulkQuote instance
        encoded_message = short_one_side_bulk_quote.encode()
        unsequenced_message = struct.pack('!BH', 104, 118)  # MessageType=104, MessageLength=6, TCP Header Length=102
        message = unsequenced_message + encoded_message

        # Print the encoded message
        print('short_one_side_bulk_quote:')
        print(message)
        return message

    elif message_type == 'LongOneSideBulkQuote':
        # Generate LongOneSideBulkQuote message
        sending_time = UTCTimestampNanos(int(time.time() * 10**9))
        cl_ord_id = ''.join(choices(string.ascii_uppercase + string.digits, k=20))
        time_in_force = TimeInForceType(value=TimeInForceType.DAY)
        exec_inst = ExecInstType(value=ExecInstType.ParticipateDoNotInitiate)
        trading_capacity = TradingCapacityType(value=TradingCapacityType.MARKET_MAKER)
        mtp_group_id = MtpGroupIDType(0)
        match_trade_prevention = MatchTradePreventionType(0)
        cancel_group_id = UINT16(0)
        risk_group_id = UINT16(0)
        efid = connection_config[session_name]['EFID']
        party_id = PartyID(efid)
        party_id_source = PartyIDSource('D')
        party_role = PartyRoleType(1)
        party_id1 = PartyID(efid)
        party_id_source1 = PartyIDSource('D')
        party_role1 = PartyRoleType(66)
        parties = [PartiesGroup(party_ids=[[party_id, party_id_source, party_role],[party_id1, party_id_source1, party_role1]])]
        quote1 = LongOneSideQuote(list_seq_no=1, options_security_id='U2cn66kp', side=SideType(value=SideType.BUY),quantity=12, price=1000000000000000)
        quote2 = LongOneSideQuote(list_seq_no=2, options_security_id='U2cn66kp', side=SideType(value=SideType.SELL),quantity=13, price=2000000000000000)

        quotes = [quote1, quote2]
        

        long_one_side_bulk_quote = LongOneSideBulkQuote(
            sending_time=sending_time,
            cl_ord_id=cl_ord_id,
            time_in_force=time_in_force,
            exec_inst=exec_inst,
            trading_capacity=trading_capacity,
            mtp_group_id=mtp_group_id,
            match_trade_prevention=match_trade_prevention,
            cancel_group_id=cancel_group_id,
            risk_group_id=risk_group_id,
            parties=parties,
            quotes=quotes
        )

       
        encoded_message = long_one_side_bulk_quote.encode()
        unsequenced_message = struct.pack('!BH', 104, 130)  # MessageType=104, MessageLength=6, TCP Header Length=102
        message = unsequenced_message + encoded_message

        # Print the encoded message
        print('long_one_side_bulk_quote:')
        print(message)
        return message
        

    else:
        raise ValueError(f"Invalid message type: {message_type}")

# Send the generated message over the TCP connection
def send_message(client_socket, message):


    # Send the message
    client_socket.sendall(message)

    # Sleep for a short period to control the message rate
    time.sleep(1 / message_rate)

def session_worker(session_name):
    try:
        # Establish SBE TCP session for the current session name
        client_socket, session_id = establish_session(session_name)

        # Start time for calculating duration
        start_time = time.time()

        # Generate and send messages for the specified duration
        while time.time() - start_time < duration:
            # Generate a random message type
            message_type = generate_message_type()

            # Generate a message based on the random message type
            message = generate_message(message_type, session_name)

            # Send the generated message over the TCP connection
            send_message(client_socket, message)
            
            '''

            
            # Define the custom TCP header format
            tcp_header_format = '!B H'
            
            # Size of the TCP header in bytes
            tcp_header_size = struct.calcsize(tcp_header_format)
            
            # Loop to receive and process incoming messages
            while True:
                # Receive the response header
                response_header = client_socket.recv(tcp_header_size)
            
                # Check if there is enough data for the TCP header
                if len(response_header) < tcp_header_size:
                    # Incomplete message, wait for more data
                    continue
            
                # Parse the TCP header
                response_type, response_length = struct.unpack(tcp_header_format, response_header)
            
                # Receive the SBE-encoded message based on the message length
                sbe_message = b''
                while len(sbe_message) < response_length:
                    chunk = client_socket.recv(response_length - len(sbe_message))
                    if not chunk:
                        # Handle the case where the connection is closed prematurely
                        break
                    sbe_message += chunk

                # Inside the loop that processes responses
                while True:
                    # ... (previous code to receive response_length and SBE-encoded message)
                
                    # Assuming sbe_header_size is the size of the SBE header in bytes
                    sbe_header_data = client_socket.recv(sbe_header_size)
                
                    # Extract fields from the SBE header
                    block_length, template_id, schema_id, version = struct.unpack('!HBBH', sbe_header_data)
                
                    # Now you have template_id, and you can decode message types based on it
                    message_type_name = None
                    for message_name, template_id_value in MESSAGE_TYPES.items():
                        if template_id == template_id_value:
                            message_type_name = message_name
                            break
                
                    if message_type_name:
                        print("Message Type Name:", message_type_name)
                    else:
                        print("Unknown Message Type")
                
                    # Continue to receive and process the rest of the SBE-encoded message
                    sbe_message_data = client_socket.recv(response_length - sbe_header_size)
                
                    # Decode and process the SBE-encoded message here
                
                # Rest of the code

            
                # Process the SBE-encoded message based on its type
                if response_type == 1:
                    # Parse and decode message type 1 using the appropriate SBE template
                    # Example: sbe_message_decoded = decode_message_type_1(sbe_message)
                    pass
                elif response_type == 2:
                    # Parse and decode message type 2 using the appropriate SBE template
                    # Example: sbe_message_decoded = decode_message_type_2(sbe_message)
                    pass
                else:
                    # Unknown message type, handle accordingly
                    pass
            
                # You can print or process the decoded message here
            
            # Close the client socket when done
            client_socket.close()




            # Receive 10 bytes of the response
            response_data = client_socket.recv(11)
            print(response_data)

            # Extract SBE header fields
            template_id = struct.unpack_from('!B', response_data, 7)[0]
            #sbe_header_data = response_data[3:]
            #block_length, template_id, schema_id, version, num_groups = struct.unpack('!H B B H B', sbe_header_data)

            # Print extracted header fields
            print("Template ID:", template_id)

                
            message_type_name = None
            for message_name, template_id_value in MESSAGE_TYPES.items():
                if template_id == template_id_value:
                   message_type_name = message_name
                   break

            if message_type_name:
                print("Message Type Name:", message_type_name)
            else:
                print("Unknown Message Type")
            '''
            

            # Sleep for a short period to control the message rate
            time.sleep(1 / message_rate)

        # Close the TCP connection for the current session
        client_socket.close()

    except Exception as e:
        print(f"Failed to establish session for {session_name}: {str(e)}")

def main():
    # Read session names from connections.cfg
    session_names = connection_config.sections()

    # List to hold the worker processes
    processes = []

    # Iterate over session names and create worker processes
    for session_name in session_names:
        process = Process(target=session_worker, args=(session_name,))
        processes.append(process)

    # Start all the worker processes
    for process in processes:
        process.start()

    # Wait for all worker processes to complete
    for process in processes:
        process.join()

    # Print the number of active sessions
    print(f"Total active sessions: {len(processes)}")

# Start the main execution
if __name__ == '__main__':
    main()





[OptionsSecurityIDs]
AMD = F0070007,F0070008
F = F0070010,F0070018
CMG = C0070010,C0070018
# Add more underliers and their associated options security IDs


# Read the underliers and their options security IDs from the configuration
options_security_ids_by_underlier = {
    'AMD': config.get('OptionsSecurityIDs', 'AMD').split(','),
    'F': config.get('OptionsSecurityIDs', 'F').split(','),
    'CMG': config.get('OptionsSecurityIDs', 'CMG').split(','),
    # Add more underliers and their associated options security IDs
}

# Randomly select an underlier
selected_underlier = choice(list(options_security_ids_by_underlier.keys()))

# Get the associated options security IDs for the selected underlier
selected_options_security_ids = options_security_ids_by_underlier[selected_underlier]

# Generate ShortTwoSideBulkQuote message
sending_time = UTCTimestampNanos(int(time.time() * 10**9))
cl_ord_id = ''.join(choices(string.ascii_uppercase + string.digits, k=20))
time_in_force = TimeInForceType(value=TimeInForceType.DAY)
exec_inst = ExecInstType(value=ExecInstType.ParticipateDoNotInitiate)
trading_capacity = TradingCapacityType(value=TradingCapacityType.MARKET_MAKER)
mtp_group_id = MtpGroupIDType(1)
match_trade_prevention = MatchTradePreventionType(1)
cancel_group_id = UINT16(1)
risk_group_id = UINT16(1)
efid = connection_config[session_name]['EFID']
party_id = PartyID(efid)
party_id_source = PartyIDSource('D')
party_role = PartyRoleType(1)
party_id1 = PartyID(efid)
party_id_source1 = PartyIDSource('D')
party_role1 = PartyRoleType(66)
parties = [PartiesGroup(party_ids=[[party_id, party_id_source, party_role],[party_id1, party_id_source1, party_role1]])]

# Randomly select an options security ID from the list associated with the selected underlier
options_security_id = choice(selected_options_security_ids)

quote1 = ShortTwoSidedQuote(list_seq_no=1, options_security_id=options_security_id, bid_size=10, bid_mantissa=50000, offer_size=20, offer_mantissa=75000)
quote2 = ShortTwoSidedQuote(list_seq_no=2, options_security_id=options_security_id, bid_size=15, bid_mantissa=80000, offer_size=25, offer_mantissa=85000)

quotes = [quote1, quote2]





















         # Define the custom TCP header format
            tcp_header_format = '!B H'
            
            # Size of the TCP header in bytes
            tcp_header_size = struct.calcsize(tcp_header_format)

            # Loop to receive and process incoming messages
            while True:

                response_header = client_socket.recv(tcp_header_size)
            
                # Check if there is enough data for the TCP header
                if len(response_header) < tcp_header_size:
                    # Incomplete message, wait for more data
                    continue
                # Receive the response header
                response_header = client_socket.recv(tcp_header_size)
            
            
                # Parse the TCP header
                response_type, response_length = struct.unpack(tcp_header_format, response_header)
            
                # Receive the SBE-encoded message based on the message length
                sbe_message = b''
                while len(sbe_message) < response_length:
                    chunk = client_socket.recv(response_length - len(sbe_message))
                    if not chunk:
                        # Handle the case where the connection is closed prematurely
                        break
                    sbe_message += chunk
                    
                    sbe_header_size = 7
                    sbe_header_data = client_socket.recv(sbe_header_size)
                
                    # Extract fields from the SBE header
                    block_length, template_id, schema_id, version = struct.unpack('!HBBH', sbe_header_data)
                
                    # Now you have template_id, and you can decode message types based on it
                    message_type_name = None
                    for message_name, template_id_value in MESSAGE_TYPES.items():
                        if template_id == template_id_value:
                            message_type_name = message_name
                            break
                
                    if message_type_name:
                        print("Message Type Name:", message_type_name)
                    else:
                        print("Unknown Message Type")
                
                    # Continue to receive and process the rest of the SBE-encoded message
                    sbe_message_data = client_socket.recv(response_length - sbe_header_size)




